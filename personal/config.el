(require 'use-package)

(setq prelude-guru nil)

(setq flycheck-check-syntax-automatically '(save
                                            mode-enabled))
(setq-default tab-width 2)
(setq multi-term-program "/usr/local/bin/zsh")
(setq explicit-shell-file-name "/usr/local/bin/zsh")
(setq ring-bell-function 'ignore)
(setq prelude-clean-whitespace-on-save t)
(setq scroll-margin 10)

(global-set-key (kbd "M-z") 'zap-up-to-char)
(global-set-key (kbd "C-x d") 'dired-jump)

(setq display-line-numbers nil)

(defun tj-newline-and-indent ()
  (interactive)
  (end-of-line)
  (newline-and-indent))
(global-set-key (kbd "<s-return>") 'tj-newline-and-indent)

(defun tj-iterm-here ()
  (interactive)
  (dired-smart-shell-command "open -a iTerm $PWD" nil nil))

(global-font-lock-mode -1)

(defun my-diff-mode-hook ()
  (font-lock-mode))
(add-hook 'diff-mode-hook 'my-diff-mode-hook)

(add-hook 'prelude-prog-mode-hook
          (lambda ()
            (setq display-line-numbers nil)
            (smartparens-mode -1)
            (electric-pair-mode)
            (electric-indent-mode))
          t)

(setq company-tooltip-align-annotations t)
(setq company-tern-property-marker "")

(defadvice split-window (after move-point-to-new-window activate)
  "Moves the point to the newly created window after splitting."
  (other-window 1))

(menu-bar-mode -1)

(set-frame-font (font-spec :family "Operator Mono" :size 14 :weight 'normal))
(add-to-list 'default-frame-alist '(font . "Operator Mono-14"))

(global-hl-line-mode -1)

(setq vc-handled-backends nil)

(add-hook 'isearch-mode-end-hook #'endless/goto-match-beginning)

(global-set-key (kbd "C-q") 'prelude-google)

(defun endless/goto-match-beginning ()
  "Go to the start of current isearch match.
Use in `isearch-mode-end-hook'."
  (when (and isearch-forward
             (number-or-marker-p isearch-other-end)
             (not mark-active)
             (not isearch-mode-end-hook-quit))
    (goto-char isearch-other-end)))

(use-package exec-path-from-shell
  :ensure t
  :config
  (exec-path-from-shell-initialize))

(defun my-hippie-expand-completions (&optional hippie-expand-function)
  "Return the full list of possible completions generated by `hippie-expand'.
    The optional argument can be generated with `make-hippie-expand-function'."
  (let ((this-command 'my-hippie-expand-completions)
        (last-command last-command)
        (buffer-modified (buffer-modified-p))
        (hippie-expand-function (or hippie-expand-function 'hippie-expand)))
    (flet ((ding)) ; avoid the (ding) when hippie-expand exhausts its options.
      (while (progn
               (funcall hippie-expand-function nil)
               (setq last-command 'my-hippie-expand-completions)
               (not (equal he-num -1)))))
    ;; Evaluating the completions modifies the buffer, however we will finish
    ;; up in the same state that we began.
    (set-buffer-modified-p buffer-modified)
    ;; Provide the options in the order in which they are normally generated.
    (delete he-search-string (reverse he-tried-table))))

(defmacro my-ido-hippie-expand-with (hippie-expand-function)
  "Generate an interactively-callable function that offers ido-based completion
    using the specified hippie-expand function."
  `(call-interactively
    (lambda (&optional selection)
      (interactive
       (let ((options (my-hippie-expand-completions ,hippie-expand-function)))
         (if options
             (list (ido-completing-read "Completions: " options)))))
      (if selection
          (he-substitute-string selection t)
        (message "No expansion found")))))

(defun my-ido-hippie-expand ()
  "Offer ido-based completion for the word at point."
  (interactive)
  (my-ido-hippie-expand-with 'hippie-expand))

(global-set-key (kbd "M-/") 'my-ido-hippie-expand)

(defun tj-marked ()
  (interactive)
  (shell-command (format "open -a \"Marked 2\" %s" (buffer-file-name))))

(use-package markdown-mode
  :ensure t

  :init
  (add-to-list 'company-dabbrev-code-modes 'markdown-mode)

  :mode
  ("\\.markdown$" . markdown-mode)
  ("\\.md$" . markdown-mode)

  :config
  (defun my-markdown-hook ()
    (flycheck-mode))
  (add-hook 'markdown-mode-hook 'my-markdown-hook))

(use-package yaml-mode
  :ensure t

  :mode

  ("\\.yaml" . yaml-mode))

(use-package org
  :ensure t
  :init
  (setq org-agenda-files (split-string (shell-command-to-string "find ~/Dropbox/org/*")))
  (setq org-src-lang-modes '(
                             ("screen" . sh)
                             ("ocaml" . tuareg)
                             ("elisp" . emacs-lisp)
                             ("lisp" . lisp)
                             ("ditaa" . artist)
                             ("asymptote" . asy)
                             ("cl" . lisp)
                             ("dot" . graphviz-dot)))
  :config
  (require 'org-table))

(add-to-list 'completion-styles 'initials t)
(add-to-list 'completion-styles 'subwords t)
(add-to-list 'completion-styles 'substring t)

(use-package company
  :ensure t
  :init
  (setq company-dabbrev-code-modes t
        company-dabbrev-code-everywhere t)
  (setq company-idle-delay 0.1)
  (setq company-echo-delay 0)
  ;; (setq company-begin-commands '(self-insert-command))
  (setq company-minimum-prefix-length 5)
  (setq company-abort-manual-when-too-short 5)
  (setq company-dabbrev-downcase nil)
  (setq company-dabbrev-ignore-case t)
  :bind
  ("TAB" . company-indent-or-complete-common))

(defun dired-back-to-top ()
  (interactive)
  (goto-char (point-min))
  (dired-next-line 4))

(define-key dired-mode-map
  (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)

(defun dired-jump-to-bottom ()
  (interactive)
  (goto-char (point-max))
  (dired-next-line -1))

(define-key dired-mode-map
  (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)

(use-package jade-mode
  :ensure t
  :config
  (setq sws-tab-width 4))

;; (use-package auto-highlight-symbol
;;   :ensure t

;;   :config
;;   (add-to-list 'ahs-plugin-bod-modes 'go-mode)
;;   (add-hook 'go-mode-hook 'auto-highlight-symbol-mode)
;;   (define-key auto-highlight-symbol-mode-map (kbd "M-p") 'ahs-backward)
;;   (define-key auto-highlight-symbol-mode-map (kbd "M-n") 'ahs-forward)
;;   (setq ahs-idle-interval 0.3) ;; if you want instant highlighting, set it to 0, but I find it annoying
;;   (setq ahs-default-range 'ahs-range-whole-buffer) ;; highlight every occurence in buffer

;;   ;; inhibits highlighting in specific places, like in comments
;;   (setq ahs-inhibit-face-list '(font-lock-comment-delimiter-face
;;                                 font-lock-comment-face
;;                                 font-lock-doc-face
;;                                 font-lock-doc-string-face
;;                                 font-lock-string-face)))

(use-package highlight-symbol
  :init
  (add-hook 'go-mode-hook 'highlight-symbol-mode)
  :config
  (global-set-key (kbd "M-p") 'highlight-symbol-prev)
  (global-set-key (kbd "M-n") 'highlight-symbol-next))

(use-package robe
  :ensure t)

(use-package ruby-mode
  :init
  (setq ruby-deep-indent-paren nil)
  :ensure t)

(use-package sh-mode
  :init
  (setq sh-basic-offset 2)
  (setq sh-basic-indentation 2)
  :mode ("\\.bats$" . sh-mode))

(use-package vkill
  :commands vkill
  :ensure t
  :bind ("C-x L" . vkill-and-helm-occur)
  :preface
  (defun vkill-and-helm-occur ()
    (interactive)
    (vkill)
    (call-interactively #'helm-occur))
  :config
  (setq vkill-show-all-processes t))

(use-package yasnippet
  :ensure t
  :config
  (yas-reload-all))

(defun check-expansion ()
  (save-excursion
    (if (looking-at "\\_>") t
      (backward-char 1)
      (if (looking-at "\\.") t
        (backward-char 1)
        (if (looking-at "->") t nil)))))

(add-hook 'find-file-hook (lambda () (global-font-lock-mode -1)))

(use-package emmet-mode
  :ensure t
  :init
  (setq emmet-move-cursor-between-quotes t)
  :config
  (add-hook 'sgml-mode-hook 'emmet-mode)
  (add-hook 'css-mode-hook  'emmet-mode))

(setq uniquify-strip-common-suffix nil)

(add-to-list 'completion-ignored-extensions ".test")

(defun tj-disable-final-newline ()
  (interactive)
  (set (make-local-variable 'require-final-newline) nil))

(add-to-list 'exec-path "~/dev/bin")
(add-to-list 'exec-path "~/bin")

(global-set-key (kbd "s-t") 'projectile-find-file)
(global-set-key (kbd "s-T") 'helm-imenu)
(global-set-key (kbd "C-M-t") 'projectile-switch-project)
(global-set-key (kbd "C-x C-b") 'helm-buffers-list)

(defun magit-key-mode--add-default-options (arguments)
  (if (eq (car arguments) 'pulling)
      (list 'pulling (list "--rebase"))
    arguments)

  (if (eq (car arguments) 'pushing)
      (list 'pushing (list "-u"))
    arguments)
  )

(use-package magithub
  :after magit
  :config
  (setq magithub-api-timeout 15))

(advice-add 'magit-key-mode :filter-args #'magit-key-mode--add-default-options)

(require 'window-number)
(setq window-number-active-background "grey")
(setq window-number-active-foreground "black")
(setq window-number-inactive-background "grey")
(setq window-number-inactive-foreground "black")
(window-number-meta-mode)

(require 'dot-mode)
(add-hook 'find-file-hooks 'dot-mode-on)

(eval-after-load "prelude-mode"
  '(progn
     (define-key prelude-mode-map (kbd "C-c s") nil)
     (define-key prelude-mode-map (kbd "M-o") nil)
     (define-key prelude-mode-map (kbd "C-c C-i") nil)
     (define-key prelude-mode-map (kbd "C-c g") nil)
     (define-key prelude-mode-map (kbd "C-c i") nil)))

(setq helm-split-window-default-side "right")

(defun tj-comment-line ()
  (interactive)
  (call-interactively #'comment-line)
  (unless (region-active-p) (previous-line)))
(global-set-key (kbd "M-;") 'tj-comment-line)

(setq comment-multi-line t)
(setq-default css-indent-offset 2)
(add-to-list 'projectile-globally-ignored-directories "Godeps/_workspace")
;; (add-to-list 'projectile-globally-ignored-directories "_build")
(add-to-list 'projectile-globally-ignored-directories "deps")
(add-to-list 'projectile-globally-ignored-directories "node_modules")
(setq-default indent-tabs-mode nil)

(global-set-key (kbd "s-s") 'save-buffer)

(add-to-list 'vc-directory-exclusion-list "node_modules")

(defun tj-projectile-find-other-file (&optional args)
  "Find other js file for `ARGS'."
  (interactive)
  (cond
   ((derived-mode-p `js-mode)
    (let* ((root (projectile-project-root))
           (this-file (buffer-file-name))
           (file-no-prefix (s-chop-prefix root this-file)))
      (if (s-prefix-p "test" file-no-prefix t)
          (find-file-other-window (concat root (s-chop-prefix "test" file-no-prefix)))
        (find-file-other-window (concat (file-name-as-directory (concat root "test")) (s-chop-prefix root this-file))))))
   ((derived-mode-p 'go-mode)
    (let* ((this-file (buffer-file-name))
           (file-no-prefix (s-chop-suffix ".go" this-file)))
      (if (s-ends-with? "test" file-no-prefix t)
          (find-file-other-window (concat (s-chop-suffix "_test" file-no-prefix) ".go"))
        (find-file-other-window (concat file-no-prefix "_test.go")))))
   (t (apply 'projectile-find-other-file args))))

(defun my-projectile-hook ()
  "Customize projectile how I want it."
  (define-key projectile-mode-map (kbd "C-c p a") 'tj-projectile-find-other-file)
  (define-key projectile-mode-map (kbd "s-p a") 'tj-projectile-find-other-file)
  (define-key projectile-mode-map (kbd "C-c p r") 'projectile-replace-regexp)
  )
(add-hook 'projectile-mode-hook 'my-projectile-hook)

(use-package avy
  :ensure t
  :bind
  ("C-j" . avy-goto-char-2)
  ("M-g g" . avy-goto-line))

(use-package avy)

(use-package avy-zap
  :ensure t
  :bind
  (("M-Z" . avy-zap-up-to-char-dwim)))

(add-hook 'cider-mode-hook #'eldoc-mode)

(add-hook 'cider-repl-mode-hook #'subword-mode)
(add-hook 'cider-repl-mode-hook #'paredit-mode)

(defun tj-visit-pull-request-url ()
  "Visit the current branch's PR on Github."
  (interactive)
  (browse-url
   (format "https://github.com/%s/pull/new/%s"
           (replace-regexp-in-string
            "\\`.+github\\.com:\\(.+\\)\\.git\\'" "\\1"
            (magit-get "remote"
                       (magit-get-remote)
                       "url"))
           (cdr (or (magit-get-remote-branch)
                    (user-error "No remote branch"))))))

(eval-after-load 'magit
  '(define-key magit-mode-map "v"
     #'tj-visit-pull-request-url))

(global-set-key (kbd "M-o") 'other-window)

(use-package eshell
  :ensure t

  :init
  (require 'em-smart)

  :bind ("M-s" . other-window-or-split)

  :config

  (setq eshell-where-to-jump 'begin)
  (setq eshell-review-quick-commands nil)
  (setq eshell-smart-space-goes-to-end t)

  (defun tj-eshell-mode-hook ()
    (setenv "PATH" (concat "/usr/local/go/bin:" "/usr/local/bin:" (getenv "PATH")))
    (setq eshell-path-env (concat "/usr/local/bin:" eshell-path-env)))


  (add-hook 'eshell-mode-hook 'tj-eshell-mode-hook)

  (use-package multi-eshell
    :ensure t

    :init
    (setq multi-eshell-shell-function '(eshell))))

(use-package magit
  :ensure t
  :init
  (setq magit-push-always-verify nil)
  :config
  (global-unset-key [tab]))

(use-package dockerfile-mode
  :ensure t
  :mode "Dockerfile")

(use-package docker
  :init
  :ensure t)

(use-package hcl-mode
  :ensure t)

(use-package magit
  :ensure t)

(use-package ag :ensure t)

(use-package restclient :ensure t
  :mode
  ("\\.rest\\'" . restclient-mode)
  :config
  (defun my-response-loaded-hook ()
    (flycheck-mode -1))
  (add-hook 'restclient-response-loaded-hook 'my-response-loaded-hook)
  (defun my-restclient-hook ()
    (setq-local indent-line-function 'js-indent-line))
  (add-hook 'restclient-mode-hook 'my-restclient-hook))

(use-package osx-clipboard
  :ensure t
  :config
  (osx-clipboard-mode))

(use-package ediff
  :ensure t
  :init
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-merge-split-window-function 'split-window-horizontally))

(use-package company-tern
  :ensure t
  :defer t
  :init
  (with-eval-after-load 'company
    (add-to-list 'company-backends 'company-tern)))

(use-package js2-mode
  :ensure t
  :init
  (setq js-indent-level 2)
  (setq-default js2-global-externs '("module" "require" "buster" "sinon" "assert" "refute" "setTimeout" "clearTimeout" "setInterval" "clearInterval" "location" "__dirname" "console" "JSON"))
  (setq-default js2-strict-inconsistent-return-warning nil)

  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint)))

  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(json-jsonlist)))


  ;; :mode
  ;; ("\\.js$" . js2-jsx-mode)
  ;; ("\\.js\\'" . js2-jsx-mode)
  ;; ("\\.json\\'" . js2-jsx-mode)

  :interpreter ("node" . js2-jsx-mode)
  :bind
  ("M-j" . comment-indent-new-line)
  ("C-c C-j" . js2-jump-to-definition)
  ("M-." . tern-find-definition)
  :config
  (defun js2-match-async-arrow-function ()
    (when (and (js2-contextual-kwd-p (js2-current-token) "async")
               (/= (js2-peek-token) js2-FUNCTION)
               (/= (js2-peek-token) js2-DOT))
      (js2-record-face 'font-lock-keyword-face)
      (js2-get-token)
      t))
  (defun my-js2-mode-hook ()
    (electric-indent-mode 1)
    (tern-mode)
    (flycheck-mode)
    (subword-mode))
  (add-hook 'js2-mode-hook 'my-js2-mode-hook))

(use-package expand-region
  :ensure t
  :bind ("C-=" . er/expand-region))

(yas-global-mode)



(use-package web-mode
  :ensure t
  :init
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint)))
  (flycheck-add-mode 'javascript-eslint 'web-mode)
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-attr-indent-offset 2)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-enable-auto-closing t)
  (setq web-mode-enable-auto-expanding t)
  (setq web-mode-enable-auto-opening t)
  (setq web-mode-enable-auto-pairing t)
  (add-to-list 'web-mode-comment-formats '("jsx" . "//"))
  (add-to-list 'web-mode-comment-formats '("javascript" . "//"))
  (setq web-mode-tag-auto-close-style 2)
  (setq web-mode-content-types-alist
        '(("jsx" . "\\.js[x]?\\'")))
  (setq web-mode-engines-alist
        '(("reactjs" . "\\.js$")))
  (with-eval-after-load 'web-mode
    (add-to-list 'web-mode-indentation-params '("lineup-args" . nil))
    (add-to-list 'web-mode-indentation-params '("lineup-concats" . nil))
    (add-to-list 'web-mode-indentation-params '("lineup-calls" . nil)))
  (setq tj--javascript-common-imenu-regex-list
        '(("Controller" "[. \t]controller([ \t]*['\"]\\([^'\"]+\\)" 1)
          ("Module" "[. \t]module( *['\"]\\([a-zA-Z0-9_.]+\\)['\"], *\\[" 1)
          ("Function" "function[ \t]+\\([a-zA-Z0-9_$.]+\\)[ \t]*(" 1)
          ("Class" "class[ \t]+\\([a-zA-Z_.]+\\)" 1)
          ("Constant" "const[ \t]+\\([a-zA-Z_.]+\\)" 1)
          ("Function" "^[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*=[ \t]*function[ \t]*(" 1)
          ))
  (defun tj--js-imenu-make-index ()
    (save-excursion
      (imenu--generic-function tj--javascript-common-imenu-regex-list)))
  (defun tj-web-mode-hook nil
    (subword-mode)
    (tern-mode)

    (setq comment-start "//"
          comment-end   "")
    (setq-local imenu-create-index-function 'tj-js-imenu-make-index))
  (add-hook 'web-mode-hook #'tj-web-mode-hook)
  :mode
  ("\\.hbs$" . web-mode)
  ("\\.eex$" . web-mode)
  ("\\.js$" . web-mode)
  :config
  (defun tjhtml-insert-open-and-close-tag ()
    "Generates an open and close HTML snippet using the current word."
    (interactive)
    (let ((inserting-new-tag nil))
      (if (looking-back "[-A-Za-z0-9:_]")
          (progn (set-mark-command nil)
                 (while (looking-back "[-A-Za-z0-9:_]")
                   (backward-char)))
        (setq inserting-new-tag t)
        (set-mark-command nil)
        (insert "p")
        (exchange-point-and-mark))
      (let ((tag (buffer-substring (region-beginning) (region-end))))
        (delete-char (string-width tag))
        (cond ((string-match "\\`[bh]r\\'" tag)
               (insert (concat "<" tag ">")))
              ((string-match (concat "\\`\\(?:img\\|meta\\|link\\|"
                                     "input\\|base\\|area\\|col\\|"
                                     "frame\\|param\\)\\'")
                             tag)
               (yas/expand-snippet (concat "<" tag " $1>$0")))
              (t
               (yas/expand-snippet
                (if inserting-new-tag
                    (concat "<${1:"
                            tag
                            "}>$0</${1:"
                            "$(and (string-match \"[-A-Za-z0-9:_]+\" yas-text) "
                            "(match-string 0 yas-text))}>")
                  (concat "<"
                          tag
                          "$1>$0</"
                          tag
                          ">"))))))))
  (defun tjerb-insert-or-toggle-erb-tag ()
    "Insert an ERb tag if the point isn't currently in one, or toggle the type."
    (interactive)
    (let ((action))
      (if (looking-at "[\s\t\n]*<%")
          (setq action 'insert)
        (save-excursion
          (let ((regex (concat "\\`<%.*%>\\'")))
            (while (or (not (region-active-p))
                       (not (or (and (= (point-min) (region-beginning))
                                     (= (point-max) (region-end)))
                                (string-match regex (buffer-substring-no-properties
                                                     (region-beginning)
                                                     (region-end))))))
              (let ((expand-region-fast-keys-enabled))
                (er/expand-region 1)))
            (let ((matched (buffer-substring-no-properties (region-beginning)
                                                           (region-end))))
              (if (string-match regex matched)
                  (progn (goto-char (+ (if (< (point) (mark)) (point) (mark)) 2))
                         (cond ((looking-at "=")
                                (delete-char 1))
                               ((looking-at "#")
                                (delete-char 1)
                                (insert "="))
                               (t
                                (insert "#"))))
                (setq action 'insert))))))
      (if (eq action 'insert)
          (progn (insert "<%=  %>")
                 (backward-char 3)))))
  :bind
  ("M-." . tern-find-definition)
  ("C-c >" . tjerb-insert-or-toggle-erb-tag)
  ("C-c <" . tjhtml-insert-open-and-close-tag))

(use-package ag
  :ensure t
  :config
  (global-set-key (kbd "C-c C-a") 'ag-regexp))

(defun goimports ()
  "Formats the current buffer according to the goimports tool."
  (interactive)
  (let ((tmpfile (make-temp-file "goimports" nil ".go"))
        (patchbuf (get-buffer-create "*Goimports patch*"))
        (errbuf (get-buffer-create "*Goimports Errors*"))
        (coding-system-for-read 'utf-8)
        (coding-system-for-write 'utf-8))

    (with-current-buffer errbuf
      (setq buffer-read-only nil)
      (erase-buffer))
    (with-current-buffer patchbuf
      (erase-buffer))

    (write-region nil nil tmpfile)

    ;; We're using errbuf for the mixed stdout and stderr output. This
    ;; is not an issue because goimports -w does not produce any stdout
    ;; output in case of success.
    (if (zerop (call-process "goimports" nil errbuf nil "-w" tmpfile))
        (if (zerop (call-process-region (point-min) (point-max) "diff" nil patchbuf nil "-n" "-" tmpfile))
            (progn
              (kill-buffer errbuf)
              (message "Buffer is already goimportsed"))
          (go--apply-rcs-patch patchbuf)
          (kill-buffer errbuf)
          (message "Applied goimports"))
      (message "Could not apply goimports. Check errors for details")
      (goimports--process-errors (buffer-file-name) tmpfile errbuf))

    (kill-buffer patchbuf)
    (delete-file tmpfile)))

(defun goimports--process-errors (filename tmpfile errbuf)
  ;; Convert the goimports stderr to something understood by the compilation mode.
  (with-current-buffer errbuf
    (goto-char (point-min))
    (insert "goimports errors:\n")
    (while (search-forward-regexp (concat "^\\(" (regexp-quote tmpfile) "\\):") nil t)
      (replace-match (file-name-nondirectory filename) t t nil 1))
    (compilation-mode)
    (display-buffer errbuf)))

(use-package company-quickhelp          ; Documentation popups for Company
  :ensure t
  :defer t
  :init (add-hook 'global-company-mode-hook #'company-quickhelp-mode))


(use-package company-jedi)

(use-package python-mode :ensure t

  :config
  (add-to-list 'company-backends 'company-jedi)
  (add-hook 'python-mode-hook 'jedi:setup)
  (setq jedi:complete-on-dot t)

  :bind
  ("M-." . jedi:goto-definition))


(eval-after-load 'company
  '(define-key company-active-map (kbd "M-h") #'company-quickhelp-manual-begin))

(use-package neotree :ensure t)

(use-package company-go
  :ensure t
  :defer t
  :init
  (with-eval-after-load 'company
    (add-to-list 'company-backends 'company-go)))

(use-package go-eldoc
  :ensure t
  :defer t
  :init
  (add-hook 'go-mode-hook 'go-eldoc-setup))

(use-package go-mode
  :defer t
  :ensure t
  :init

  (load "~/dev/src/github.com/stapelberg/expanderr/expanderr.el")

  (setq gofmt-command "goimports")
  (setenv "GOPATH" (expand-file-name (concat (getenv "HOME") "/dev")))
  (setq company-go-show-annotation t)
  (add-hook 'go-mode-hook #'go-guru-hl-identifier-mode)

  (eval-after-load "go-mode"
    '(progn
       (define-key go-mode-map (kbd "C-c C-a") nil)
       ))

  :bind

  ("C-c C-d" . go-guru-describe)
  ("C-c C-i" . goimports)
  ("C-c C-r" . godoctor-rename)
  ("C-c C-g" . helm-go-package)
  ("C-c C-c" . godoc-at-point)
  ("C-c C-t" . go-test-current-file)
  ("C-c C-p" . go-playground)
  ("C-c g" . godoc)
  ("M-j" . comment-indent-new-line)
  ("M-." . go-guru-definition)

  :config

  (add-hook 'before-save-hook 'gofmt-before-save)
  ;; (add-to-list (make-local-variable 'company-backends) 'company-go)
  (defun my-go-hook ()
    (setq display-line-numbers nil)
    (subword-mode)
    (flycheck-mode)
    (electric-indent-mode)
    (if (not (string-match "go" compile-command))
        (set (make-local-variable 'compile-command)
             "go build -v && go test -v && go vet")))
  (add-hook 'go-mode-hook 'my-go-hook)
  (use-package gotest :ensure t))


(use-package elixir-mode
  :ensure t
  :init
  (defun my-elixir-hook ()
    (subword-mode)
    (flycheck-mode)
    (alchemist-mode))
  (add-hook 'elixir-mode-hook 'my-elixir-hook))

(use-package elixir-yasnippets
  :ensure t)

(use-package alchemist
  :ensure t
  :bind
  ("M-j" . comment-indent-new-line))

(use-package embrace
  :ensure t)

(use-package projectile-rails
  :ensure t
  :config
  (projectile-rails-global-mode))

(use-package helm-ag
  :ensure t
  :bind (("s-F" . ag-regexp)))

(use-package helm
  :ensure t
  :bind (("C-c h"   . helm-command-prefix)
         ("C-h a"   . helm-apropos)
         ("C-x f"   . helm-multi-files)
         ("C-c C-o"   . helm-occur)
         ("C-c i" . helm-imenu)
         ("M-H"     . helm-resume)
         ("M-x"     . helm-M-x)
         ("C-x C-m"     . helm-M-x)
         ("C-x b" . helm-mini)
         ("C-x C-f" . helm-find-files)
         ("M-y" . helm-show-kill-ring)
         )

  :preface
  (defun my-helm-find ()
    (interactive)
    (helm-find nil))

  :config

  (use-package helm-open-github
    :ensure t

    :config

    (define-prefix-command 'tjopen-map)
    (global-set-key (kbd "C-c o") 'tjopen-map)

    :bind

    (("C-c o o" . prelude-open-with)
     ("C-c o f" . helm-open-github-from-file)
     ("C-c o c" . helm-open-github-from-commit)
     ("C-c o i" . helm-open-github-from-issues)
     ("C-c o p" . helm-open-github-from-pull-requests)
     ("C-c u" . browse-url-at-point)
     ("C-\\" . er/expand-region)
     ("C->" . mc/mark-all-like-this-dwim)))

  (use-package helm-swoop
    :ensure t

    :init

    (setq helm-swoop-split-window-function
      (lambda ($buf)
        (if helm-swoop-split-with-multiple-windows
            (funcall helm-swoop-split-right)
          (when (one-window-p)
            (funcall helm-swoop-split-direction)))
        (switch-to-buffer $buf)))

    (setq helm-swoop-split-direction 'split-window-horizontally)
    (setq helm-buffers-fuzzy-matching t)
    (setq helm-recentf-fuzzy-match t)
    (setq helm-imenu-fuzzy-match t)
    (setq helm-semantic-fuzzy-match t)
    (setq helm-apropos-fuzzy-match t)
    (setq helm-M-x-fuzzy-match t)
    (setq helm-swoop-use-fuzzy-match t)
    (setq helm-swoop-use-line-number-face t)

    :bind (("M-i" . helm-swoop))

    :config

    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch))

  (use-package helm-mode
    :diminish helm-mode
    :init
    (helm-mode 1))

  (use-package helm-multi-match)

  (helm-autoresize-mode 1)

  (bind-key "<tab>" #'helm-execute-persistent-action helm-map)
  (bind-key "C-i" #'helm-execute-persistent-action helm-map)
  (bind-key "C-z" #'helm-select-action helm-map)
  (bind-key "A-v" #'helm-previous-page helm-map))

(global-set-key (kbd "C-c c") #'embrace-commander)

(use-package web-beautify
  :ensure t)

(defadvice compile-goto-error (around my-compile-goto-error activate)
  (let ((display-buffer-overriding-action '(display-buffer-reuse-window (inhibit-same-window . nil))))
    ad-do-it))

(defun tjesformatter ()
  (interactive)
  (shell-command (format "esformatter -i %s" (buffer-file-name))))

(defun zap-to-isearch (rbeg rend)
  "Kill the region between the mark and the closest portion of
  the isearch match string. The behaviour is meant to be analogous
  to zap-to-char; let's call it zap-to-isearch. The deleted region
  does not include the isearch word. This is meant to be bound only
  in isearch mode.
  The point of this function is that oftentimes you want to delete
  some portion of text, one end of which happens to be an active
  isearch word. The observation to make is that if you use isearch
  a lot to move the cursor around (as you should, it is much more
  efficient than using the arrows), it happens a lot that you could
  just delete the active region between the mark and the point, not
  include the isearch word."
  (interactive "r")
  (when (not mark-active)
    (error "Mark is not active"))
  (let* ((isearch-bounds (list isearch-other-end (point)))
         (ismin (apply 'min isearch-bounds))
         (ismax (apply 'max isearch-bounds))
         )
    (if (< (mark) ismin)
        (kill-region (mark) ismin)
      (if (> (mark) ismax)
          (kill-region ismax (mark))
        (error "Internal error in isearch kill function.")))
    (isearch-exit)))
(define-key isearch-mode-map [(meta z)] 'zap-to-isearch)

(autoload 'zap-up-to-char "misc"
  "Kill up to, but not including ARGth occurrence of CHAR.

  \(fn arg char)"
  'interactive)

(use-package sql
  :ensure t

  :init

  (defun my-sql-mode-hook ()
    (electric-indent-mode -1))
  (add-hook 'sql-mode-hook 'my-sql-mode-hook)

  :config
  (eval-after-load "sql"
    '(load-library "sql-indent")))

(defun tjtitle-case-region-or-line (*begin *end)
  "Title case text between nearest brackets, or current line, or text selection.
Capitalize first letter of each word, except words like {to, of, the, a, in, or, and, …}. If a word already contains cap letters such as HTTP, URL, they are left as is.

When called in a elisp program, *begin *end are region boundaries.
URL `http://ergoemacs.org/emacs/elisp_title_case_text.html'
Version 2015-05-07"
  (interactive
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (let (
           -p1
           -p2
           (-skipChars "^\"<>(){}[]“”‘’‹›«»「」『』【】〖〗《》〈〉〔〕"))
       (progn
         (skip-chars-backward -skipChars (line-beginning-position))
         (setq -p1 (point))
         (skip-chars-forward -skipChars (line-end-position))
         (setq -p2 (point)))
       (list -p1 -p2))))
  (let* (
         (-strPairs [
                     [" A " " a "]
                     [" And " " and "]
                     [" At " " at "]
                     [" As " " as "]
                     [" By " " by "]
                     [" Be " " be "]
                     [" Into " " into "]
                     [" In " " in "]
                     [" Is " " is "]
                     [" It " " it "]
                     [" For " " for "]
                     [" Of " " of "]
                     [" Or " " or "]
                     [" On " " on "]
                     [" Via " " via "]
                     [" The " " the "]
                     [" That " " that "]
                     [" To " " to "]
                     [" Vs " " vs "]
                     [" With " " with "]
                     [" From " " from "]
                     ["'S " "'s "]
                     ]))
    (save-excursion
      (save-restriction
        (narrow-to-region *begin *end)
        (upcase-initials-region (point-min) (point-max))
        (let ((case-fold-search nil))
          (mapc
           (lambda (-x)
             (goto-char (point-min))
             (while
                 (search-forward (aref -x 0) nil t)
               (replace-match (aref -x 1) 'FIXEDCASE 'LITERAL)))
           -strPairs))))))

;; nice-jumper. vim-like jumping.

(require 'nice-jumper)
(global-nice-jumper-mode t)
(global-set-key (kbd "C-o") 'nice-jumper/backward)
(global-set-key (kbd "C-i") 'nice-jumper/forward)

(server-start)
